#!/usr/bin/perl
# $Id: service.in,v 1.118 2005/10/19 01:22:14 don Exp $
#
# Usage: service <code>.nn
# Temps:  incoming/P<code>.nn

use File::Copy;
use MIME::Parser;
use Debbugs::MIME qw(decode_rfc1522 encode_rfc1522);
use Debbugs::Mail qw(send_mail_message);
use Debbugs::User;

$config_path = '/etc/debbugs';
$lib_path = '/usr/lib/debbugs';

require "$config_path/config";
require "$lib_path/errorlib";
$ENV{'PATH'} = $lib_path.':'.$ENV{'PATH'};

chdir("$gSpoolDir") || die "chdir spool: $!\n";

# open(DEBUG,">&4");
open DEBUG, ">/dev/null";
$debug = 0;
umask(002);

$_=shift;
m/^[RC]\.\d+$/ || &quit("bad argument");
$control= m/C/;
$nn= $_;
if (!rename("incoming/G$nn","incoming/P$nn")) {
    $_=$!.'';  m/no such file or directory/i && exit 0;
    &quit("renaming to lock: $!");
}    

open(M,"incoming/P$nn");
@log=<M>;
@msg=@log;
close(M);

chomp @msg;

print "###\n",join("##\n",@msg),"\n###\n" if $debug;

my $parser = new MIME::Parser;
mkdir "$gSpoolDir/mime.tmp", 0777;
$parser->output_under("$gSpoolDir/mime.tmp");
my $entity = eval { $parser->parse_data(join('',@log)) };

# header and decoded body respectively
my (@headerlines, @bodylines);
# Bug numbers to send e-mail to, hash so that we don't send to the
# same bug twice.
my (%bug_affected);

if ($entity and $entity->head->tags) {
    @headerlines = @{$entity->head->header};
    chomp @headerlines;

    my $entity_body = getmailbody($entity);
    @bodylines = $entity_body ? $entity_body->as_lines() : ();
    chomp @bodylines;
} else {
    # Legacy pre-MIME code, kept around in case MIME::Parser fails.
    my $i;
    for ($i = 0; $i <= $#msg; $i++) {
	$_ = $msg[$i];
	last unless length($_);
	while ($msg[$i+1] =~ m/^\s/) {
	    $i++;
	    $_ .= "\n".$msg[$i];
	}
	push @headerlines, $_;
    }

    @bodylines = @msg[$i..$#msg];
}

for (@headerlines) {
    $_ = decode_rfc1522($_);
    s/\n\s/ /g;
    print ">$_<\n" if $debug;
    if (s/^(\S+):\s*//) {
	my $v = lc $1;
	print ">$v=$_<\n" if $debug;
	$header{$v} = $_;
    } else {
	print "!>$_<\n" if $debug;
    }
}

# Strip off RFC2440-style PGP clearsigning.
if (@bodylines and $bodylines[0] =~ /^-----BEGIN PGP SIGNED/) {
    shift @bodylines while @bodylines and length $bodylines[0];
    shift @bodylines while @bodylines and $bodylines[0] !~ /\S/;
    for my $findsig (0 .. $#bodylines) {
	if ($bodylines[$findsig] =~ /^-----BEGIN PGP SIGNATURE/) {
	    $#bodylines = $findsig - 1;
	    last;
	}
    }
    map { s/^- // } @bodylines;
}

grep(s/\s+$//,@bodylines);

print "***\n",join("\n",@bodylines),"\n***\n" if $debug;

if (defined $header{'resent-from'} && !defined $header{'from'}) {
    $header{'from'} = $header{'resent-from'};
}

defined($header{'from'}) || &quit("no From header");

delete $header{'reply-to'} 
	if ( defined($header{'reply-to'}) && $header{'reply-to'} =~ m/^\s*$/ );

if ( defined($header{'reply-to'}) && $header{'reply-to'} ne "" ) {
    $replyto = $header{'reply-to'};
} else {
    $replyto = $header{'from'};
}

$controlrequestaddr= $control ? "control\@$gEmailDomain" : "request\@$gEmailDomain";
$transcript='';
&transcript("Processing commands for $controlrequestaddr:\n\n");

$dl= 0;
$state= 'idle';
$lowstate= 'idle';
$mergelowstate= 'idle';
$midix=0;    
$extras="";

my $user = $replyto;
$user =~ s/,.*//;
$user =~ s/^.*<(.*)>.*$/$1/;
$user =~ s/[(].*[)]//;
$user =~ s/^\s*(\S+)\s+.*$/$1/;
$user = "" unless (Debbugs::User::is_valid_user($user));

my $quickabort = 0;

my $fuckheads = "(" . join("|", @gFuckheads) . ")";
if (@gFuckheads and $replyto =~ m/$fuckheads/) {
	&transcript("This service is unavailable.\n\n");
	$quickabort = 1;
}

my %limit_pkgs = ();
my %clonebugs = ();
my @bcc = ();

sub addbcc {
    push @bcc, $_[0] unless grep { $_ eq $_[0] } @bcc;
}

for ($procline=0; $procline<=$#bodylines; $procline++) {
    $state eq 'idle' || print "$state ?\n";
    $lowstate eq 'idle' || print "$lowstate ?\n";
    $mergelowstate eq 'idle' || print "$mergelowstate ?\n";
    if ($quickabort) {
         &transcript("Stopping processing here.\n\n");
	 last;
    }
    $_= $bodylines[$procline]; s/\s+$//;
    next unless m/\S/;
    &transcript("> $_\n");
    next if m/^\s*\#/;
    $action= '';
    if (m/^stop\s*$/i || m/^quit\s*$/i || m/^--\s*$/ || m/^thank(?:s|\s*you)?\s*$/i || m/^kthxbye\s*$/i) {
	&transcript("Stopping processing here.\n\n");
        last;
    } elsif (m/^debug\s+(\d+)$/i && $1 >= 0 && $1 <= 1000) {
        $dl= $1+0;
        &transcript("Debug level $dl.\n\n");
    } elsif (m/^(send|get)\s+\#?(\d{2,})$/i) {
        $ref= $2+0;
        &sendlynxdoc("bugreport.cgi?bug=$ref","logs for $gBug#$ref");
    } elsif (m/^send-detail\s+\#?(\d{2,})$/i) {
	$ref= $1+0;
	&sendlynxdoc("bugreport.cgi?bug=$ref&boring=yes",
		     "detailed logs for $gBug#$ref");
    } elsif (m/^index(\s+full)?$/i) {
	&transcript("This BTS function is currently disabled, sorry.\n\n");
	$ok++; # well, it's not really ok, but it fixes #81224 :)
    } elsif (m/^index-summary\s+by-package$/i) {
	&transcript("This BTS function is currently disabled, sorry.\n\n");
	$ok++; # well, it's not really ok, but it fixes #81224 :)
    } elsif (m/^index-summary(\s+by-number)?$/i) {
	&transcript("This BTS function is currently disabled, sorry.\n\n");
	$ok++; # well, it's not really ok, but it fixes #81224 :)
    } elsif (m/^index(\s+|-)pack(age)?s?$/i) {
	&sendlynxdoc("pkgindex.cgi?indexon=pkg",'index of packages');
    } elsif (m/^index(\s+|-)maints?$/i) {
	&sendlynxdoc("pkgindex.cgi?indexon=maint",'index of maintainers');
    } elsif (m/^index(\s+|-)maint\s+(\S+)$/i) {
	$maint = $2;
	&sendlynxdoc("pkgreport.cgi?maint=" . urlsanit($maint),
		     "$gBug list for maintainer \`$maint'");
        $ok++;
    } elsif (m/^index(\s+|-)pack(age)?s?\s+(\S.*\S)$/i) {
	$package = $+;
	&sendlynxdoc("pkgreport.cgi?pkg=" . urlsanit($package),
		     "$gBug list for package $package");
        $ok++;
    } elsif (m/^send-unmatched(\s+this|\s+-?0)?$/i) {
	&transcript("This BTS function is currently disabled, sorry.\n\n");
	$ok++; # well, it's not really ok, but it fixes #81224 :)
    } elsif (m/^send-unmatched\s+(last|-1)$/i) {
	&transcript("This BTS function is currently disabled, sorry.\n\n");
	$ok++; # well, it's not really ok, but it fixes #81224 :)
    } elsif (m/^send-unmatched\s+(old|-2)$/i) {
	&transcript("This BTS function is currently disabled, sorry.\n\n");
	$ok++; # well, it's not really ok, but it fixes #81224 :)
    } elsif (m/^getinfo\s+([\w-.]+)$/i) {
        # the following is basically a Debian-specific kludge, but who cares
        $req = $1;
	if ($req =~ /^maintainers$/i && -f "$gConfigDir/Maintainers") {
	    &sendinfo("local", "$gConfigDir/Maintainers", "Maintainers file");
	} elsif ($req =~ /^override\.(\w+)\.([\w-.]+)$/i) {
	    $req =~ s/.gz$//;
	    &sendinfo("ftp.d.o", "$req", "override file for $2 part of $1 distribution");
	} elsif ($req =~ /^pseudo-packages\.(description|maintainers)$/i && -f "$gConfigDir/$req") {
	    &sendinfo("local", "$gConfigDir/$req", "$req file");
	} else {
	    &transcript("Info file $req does not exist.\n\n");
	}
    } elsif (m/^help/i) {
        &sendhelp;
        &transcript("\n");
        $ok++;
    } elsif (m/^refcard/i) {
        &sendtxthelp("bug-mailserver-refcard.txt","mail servers' reference card");
    } elsif (m/^subscribe/i) {
        &transcript(<<END);
There is no $gProject $gBug mailing list.  If you wish to review bug reports
please do so via http://$gWebDomain/ or ask this mail server
to send them to you.
soon: MAILINGLISTS_TEXT
END
    } elsif (m/^unsubscribe/i) {
        &transcript(<<END);
soon: UNSUBSCRIBE_TEXT
soon: MAILINGLISTS_TEXT
END
    } elsif (m/^user\s+(\S+)\s*$/i) {
        my $newuser = $1;
	if (Debbugs::User::is_valid_user($newuser)) {
	    my $olduser = ($user ne "" ? " (was $user)" : "");
            &transcript("Setting user to $newuser$olduser.\n");
	    $user = $newuser;
	} else {
	    &transcript("Selected user id ($newuser) invalid, sorry\n");
	    $user = "";
	}
    } elsif (m/^usercategory\s+(\S+)(\s+\[hidden\])?\s*$/i) {
        $ok++;
	my $catname = $1;
	my $hidden = ($2 ne "");

        my $prefix = "";
        my @cats;
        my $bad = 0;
	my $catsec = 0;
        while (++$procline <= $#bodylines) {
            unless ($bodylines[$procline] =~ m/^\s*([*+])\s*(\S.*)$/) {
                $procline--;
                last;
            }
            &transcript("> $bodylines[$procline]\n");
            next if $bad;
            my ($o, $txt) = ($1, $2);
            if ($#cats == -1 && $o eq "+") {
                &transcript("User defined category specification must start with a category name. Skipping.\n\n");
                $bad = 1;
                next;
            }
            if ($o eq "+") {
	        unless (ref($cats[-1]) eq "HASH") {
		    $cats[-1] = { "nam" => $cats[-1], 
		                  "pri" => [], "ttl" => [] };
		}
	        $catsec++;
		my ($desc, $ord, $op);
                if ($txt =~ m/^(.*\S)\s*\[((\d+):\s*)?\]\s*$/) {
                    $desc = $1; $ord = $3; $op = "";
                } elsif ($txt =~ m/^(.*\S)\s*\[((\d+):\s*)?(\S+)\]\s*$/) {
                    $desc = $1; $ord = $3; $op = $4;
                } elsif ($txt =~ m/^([^[\s]+)\s*$/) {
                    $desc = ""; $op = $1;
                } else {
                    &transcript("Unrecognised syntax for category section. Skipping.\n\n");
                    $bad = 1;
                    next;
                }
		$ord = 999 unless defined $ord;

		if ($op) {
                    push @{$cats[-1]->{"pri"}}, $prefix . $op;
		    push @{$cats[-1]->{"ttl"}}, $desc;
		    push @ords, "$ord $catsec";
		} else {
		    @cats[-1]->{"def"} = $desc;
		    push @ords, "$ord DEF";
		    $catsec--;
		}
		@ords = sort { my ($a1, $a2, $b1, $b2) = split / /, "$a $b";
		               $a1 <=> $b1 || $a2 <=> $b2; } @ords;
		$cats[-1]->{"ord"} = [map { m/^.* (\S+)/; $1 eq "DEF" ? $catsec + 1 : $1 } @ords];
            } elsif ($o eq "*") {
	        $catsec = 0;
                my ($name);
                if ($txt =~ m/^(.*\S)(\s*\[(\S+)\])\s*$/) {
                    $name = $1; $prefix = $3;
                } else {
                    $name = $txt; $prefix = "";
                }
                push @cats, $name;
            }
        }
        # XXX: got @cats, now do something with it
	my $u = Debbugs::User::get_user($user);
	if (@cats) {
	    &transcript("Added usercategory $catname.\n\n");
	    $u->{"categories"}->{$catname} = [ @cats ];
	} else {
	    &transcript("Removed usercategory $catname.\n\n");
	    delete $u->{"categories"}->{$catname};
	}
	$u->write();
    } elsif (m/^usertags?\s+\#?(-?\d+)\s+(([=+-])\s*)?(\S.*)?$/i) {
	$ok++;
	$ref = $1; $addsubcode = $3 || "+"; $tags = $4;
	if ($user eq "") {
	    &transcript("No valid user selected\n");
        } elsif (&setbug) {
	    &nochangebug;
	    my %ut;
	    Debbugs::User::read_usertags(\%ut, $user);
            my @oldtags = (); my @newtags = (); my @badtags = ();
	    my %chtags;
	    for my $t (split /[,\s]+/, $tags) {
	        if ($t =~ m/^[a-zA-Z0-9.+\@-]+$/) {
		    $chtags{$t} = 1;
		} else {
		    push @badtags, $t;
		}
	    }
	    if (@badtags) {
                &transcript("Ignoring illegal tag/s: ".join(', ', @badtags).".\nPlease use only alphanumerics, at, dot, plus and dash.\n");
	    }
            for my $t (keys %chtags) {
	        $ut{$t} = [] unless defined $ut{$t};
	    }
	    for my $t (keys %ut) {
		my %res = map { ($_, 1) } @{$ut{$t}};
		push @oldtags, $t if defined $res{$ref};
		my $addop = ($addsubcode eq "+" or $addsubcode eq "=");
		my $del = (defined $chtags{$t} ? $addsubcode eq "-" 
		                               : $addsubcode eq "=");
		$res{$ref} = 1 if ($addop && defined $chtags{$t});
		delete $res{$ref} if ($del);
		push @newtags, $t if defined $res{$ref};
		$ut{$t} = [ sort { $a <=> $b } (keys %res) ];
	    }
	    if (@oldtags == 0) {
		&transcript("There were no usertags set.\n");
	    } else {
		&transcript("Usertags were: " . join(" ", @oldtags) . ".\n");
	    }
	    &transcript("Usertags are now: " . join(" ", @newtags) . ".\n");
	    Debbugs::User::write_usertags(\%ut, $user);
	}
    } elsif (!$control) {
        &transcript(<<END);
Unknown command or malformed arguments to command.
(Use control\@$gEmailDomain to manipulate reports.)

END
        if (++$unknowns >= 3) {
            &transcript("Too many unknown commands, stopping here.\n\n");
            last;
        }
#### "developer only" ones start here
    } elsif (m/^close\s+\#?(-?\d+)(?:\s+(\d.*))?$/i) {
	$ok++;
	$ref= $1;
	$bug_affected{$ref}=1;
	$version= $2;
	if (&setbug) {
	    &transcript("'close' is deprecated; see http://$gWebDomain/Developer$gHTMLSuffix#closing.\n");
	    if (length($data->{done}) and not defined($version)) {
		&transcript("$gBug is already closed, cannot re-close.\n\n");
                &nochangebug;
            } else {
                $action= "$gBug " .
                    (defined($version) ?
                        "marked as fixed in version $version" :
                        "closed") .
                    ", send any further explanations to $data->{originator}";
                do {
                    &addmaintainers($data);
					if ( length( $gDoneList ) > 0 && length( $gListDomain ) >
					0 ) { &addccaddress("$gDoneList\@$gListDomain"); }
                    $data->{done}= $replyto;
                    my @keywords= split ' ', $data->{keywords};
                    if (grep $_ eq 'pending', @keywords) {
                        $extramessage= "Removed pending tag.\n";
                        $data->{keywords}= join ' ', grep $_ ne 'pending',
                                                @keywords;
                    }
                    addfixedversions($data, $data->{package}, $version, 'binary');

		    $message= <<END;
From: $gMaintainerEmail ($gProject $gBug Tracking System)
To: $data->{originator}
Subject: $gBug#$ref acknowledged by developer
         ($header{'subject'})
References: $header{'message-id'} $data->{msgid}
In-Reply-To: $data->{msgid}
Message-ID: <handler.$ref.$nn.notifdonectrl.$midix\@$gEmailDomain>
Reply-To: $ref\@$gEmailDomain
X-$gProject-PR-Message: they-closed-control $ref

This is an automatic notification regarding your $gBug report
#$ref: $data->{subject},
which was filed against the $data->{package} package.

It has been marked as closed by one of the developers, namely
$replyto.

You should be hearing from them with a substantive response shortly,
in case you haven't already. If not, please contact them directly.

$gMaintainer
(administrator, $gProject $gBugs database)

END
                    &sendmailmessage($message,$data->{originator});
                } while (&getnextbug);
            }
        }
    } elsif (m/^reassign\s+\#?(-?\d+)\s+(\S+)(?:\s+(\d.*))?$/i) {
        $ok++;
        $ref= $1; $newpackage= $2;
	$bug_affected{$ref}=1;
        $version= $3;
    	$newpackage =~ y/A-Z/a-z/;
        if (&setbug) {
            if (length($data->{package})) {
                $action= "$gBug reassigned from package \`$data->{package}'".
                         " to \`$newpackage'.";
            } else {
                $action= "$gBug assigned to package \`$newpackage'.";
            }
            do {
                &addmaintainers($data);
                $data->{package}= $newpackage;
                $data->{found_versions}= [];
                $data->{fixed_versions}= [];
                # TODO: what if $newpackage is a source package?
                addfoundversions($data, $data->{package}, $version, 'binary');
                &addmaintainers($data);
            } while (&getnextbug);
        }
    } elsif (m/^reopen\s+\#?(-?\d+)$/i ? ($noriginator='', 1) :
             m/^reopen\s+\#?(-?\d+)\s+\=$/i ? ($noriginator='', 1) :
             m/^reopen\s+\#?(-?\d+)\s+\!$/i ? ($noriginator=$replyto, 1) :
             m/^reopen\s+\#?(-?\d+)\s+(\S.*\S)$/i ? ($noriginator=$2, 1) : 0) {
        $ok++;
        $ref= $1;
	$bug_affected{$ref}=1;
        if (&setbug) {
            if (@{$data->{fixed_versions}}) {
                &transcript("'reopen' is deprecated when a bug has been closed with a version;\nuse 'found' or 'submitter' as appropriate instead.\n");
            }
            if (!length($data->{done})) {
                &transcript("$gBug is already open, cannot reopen.\n\n");
                &nochangebug;
            } else {
                $action=
                    $noriginator eq '' ? "$gBug reopened, originator not changed." :
                        "$gBug reopened, originator set to $noriginator.";
                do {
                    &addmaintainers($data);
                    $data->{originator}= $noriginator eq '' ?  $data->{originator} : $noriginator;
                    $data->{fixed_versions}= [];
                    $data->{done}= '';
                } while (&getnextbug);
            }
        }
    } elsif (m/^found\s+\#?(-?\d+)(?:\s+(\d.*))?$/i) {
        $ok++;
        $ref= $1;
        $version= $2;
        if (&setbug) {
            if (!length($data->{done}) and not defined($version)) {
                &transcript("$gBug is already open, cannot reopen.\n\n");
                &nochangebug;
            } else {
                $action=
                    defined($version) ?
                        "$gBug marked as found in version $version." :
                        "$gBug reopened.";
                do {
                    &addmaintainers($data);
                    # The 'done' field gets a bit weird with version
                    # tracking, because a bug may be closed by multiple
                    # people in different branches. Until we have something
                    # more flexible, we set it every time a bug is fixed,
                    # and clear it precisely when a found command is
                    # received for the rightmost fixed-in version, which
                    # equates to the most recent fixing of the bug, or when
                    # a versionless found command is received.
                    if (defined $version) {
                        my $lastfixed = $data->{fixed_versions}[-1];
                        # TODO: what if $data->{package} is a source package?
                        addfoundversions($data, $data->{package}, $version, 'binary');
                        if (defined $lastfixed and not grep { $_ eq $lastfixed } @{$data->{fixed_versions}}) {
                            $data->{done} = '';
                        }
                    } else {
                        # Versionless found; assume old-style "not fixed at
                        # all".
                        $data->{fixed_versions} = [];
                        $data->{done} = '';
                    }
                } while (&getnextbug);
            }
        }
    } elsif (m/^notfound\s+\#?(-?\d+)\s+(\d.*)$/i) {
        $ok++;
        $ref= $1;
        $version= $2;
        if (&setbug) {
            $action= "$gBug marked as not found in version $version.";
            if (length($data->{done})) {
                $extramessage= "(By the way, this $gBug is currently marked as done.)\n";
            }
            do {
                &addmaintainers($data);
                removefoundversions($data, $data->{package}, $version, 'binary');
            } while (&getnextbug);
        }
    } elsif (m/^submitter\s+\#?(-?\d+)\s+\!$/i ? ($newsubmitter=$replyto, 1) :
             m/^submitter\s+\#?(-?\d+)\s+(\S.*\S)$/i ? ($newsubmitter=$2, 1) : 0) {
        $ok++;
        $ref= $1;
	$bug_affected{$ref}=1;
        if ($ref =~ m/^-\d+$/ && defined $clonebugs{$ref}) {
            $ref = $clonebugs{$ref};
        }
        if (&getbug) {
            if (&checkpkglimit) {
                &foundbug;
                &addmaintainers($data);
                $oldsubmitter= $data->{originator};
                $data->{originator}= $newsubmitter;
                $action= "Changed $gBug submitter from $oldsubmitter to $newsubmitter.";
                &savebug;
                &transcript("$action\n");
                if (length($data->{done})) {
                    &transcript("(By the way, that $gBug is currently marked as done.)\n");
                }
                &transcript("\n");
                $message= <<END;
From: $gMaintainerEmail ($gProject $gBug Tracking System)
To: $oldsubmitter
Subject: $gBug#$ref submitter address changed
         ($header{'subject'})
References: $header{'message-id'} $data->{msgid}
In-Reply-To: $data->{msgid}
Message-ID: <handler.$ref.$nn.newsubmitter.$midix\@$gEmailDomain>
Reply-To: $ref\@$gEmailDomain
X-$gProject-PR-Message: submitter-changed $ref

The submitter address recorded for your $gBug report
#$ref: $data->{subject}
has been changed.

The old submitter address for this report was
$oldsubmitter.
The new submitter address is
$newsubmitter.

This change was made by
$replyto.
If it was incorrect, please contact them directly.

$gMaintainer
(administrator, $gProject $gBugs database)

END
                &sendmailmessage($message,$oldsubmitter);
            } else {
                &cancelbug;
            }
        } else {
            &notfoundbug;
        }
    } elsif (m/^forwarded\s+\#?(-?\d+)\s+(\S.*\S)$/i) {
        $ok++;
        $ref= $1; $whereto= $2;
	$bug_affected{$ref}=1;
        if (&setbug) {
            if (length($data->{forwarded})) {
    $action= "Forwarded-to-address changed from $data->{forwarded} to $whereto.";
            } else {
    $action= "Noted your statement that $gBug has been forwarded to $whereto.";
            }
            if (length($data->{done})) {
                $extramessage= "(By the way, this $gBug is currently marked as done.)\n";
            }
            do {
                &addmaintainers($data);
		if (length($gForwardList)>0 && length($gListDomain)>0 ) {
		     &addccaddress("$gForwardList\@$gListDomain"); 
		}
                $data->{forwarded}= $whereto;
            } while (&getnextbug);
        }
    } elsif (m/^notforwarded\s+\#?(-?\d+)$/i) {
        $ok++;
        $ref= $1;
	$bug_affected{$ref}=1;
        if (&setbug) {
            if (!length($data->{forwarded})) {
                &transcript("$gBug is not marked as having been forwarded.\n\n");
                &nochangebug;
            } else {
    $action= "Removed annotation that $gBug had been forwarded to $data->{forwarded}.";
                do {
                    &addmaintainers($data);
                    $data->{forwarded}= '';
                } while (&getnextbug);
            }
        }
    } elsif (m/^severity\s+\#?(-?\d+)\s+([-0-9a-z]+)$/i ||
	m/^priority\s+\#?(-?\d+)\s+([-0-9a-z]+)$/i) {
        $ok++;
        $ref= $1;
	$bug_affected{$ref}=1;
        $newseverity= $2;
        if (!grep($_ eq $newseverity, @gSeverityList, "$gDefaultSeverity")) {
            &transcript("Severity level \`$newseverity' is not known.\n".
 			"Recognized are: $gShowSeverities.\n\n");
        } elsif (exists $gObsoleteSeverities{$newseverity}) {
            &transcript("Severity level \`$newseverity' is obsolete. " .
                        "$gObsoleteSeverities{$newseverity}\n\n");
        } elsif (&setbug) {
            $printseverity= $data->{severity};
            $printseverity= "$gDefaultSeverity" if $printseverity eq '';
	    $action= "Severity set to \`$newseverity' from \`$printseverity'";
	    do {
                &addmaintainers($data);
                if (defined $gStrongList and isstrongseverity($newseverity)) {
                    addbcc("$gStrongList\@$gListDomain");
                }
                $data->{severity}= $newseverity;
            } while (&getnextbug);
        }
    } elsif (m/^tags?\s+\#?(-?\d+)\s+(([=+-])\s*)?(\S.*)?$/i) {
	$ok++;
	$ref = $1; $addsubcode = $3; $tags = $4;
	$bug_affected{$ref}=1;
	$addsub = "add";
	if (defined $addsubcode) {
	    $addsub = "sub" if ($addsubcode eq "-");
	    $addsub = "add" if ($addsubcode eq "+");
	    $addsub = "set" if ($addsubcode eq "=");
	}
	my @okaytags = ();
	my @badtags = ();
	foreach my $t (split /[\s,]+/, $tags) {
	    if (!grep($_ eq $t, @gTags)) {
		push @badtags, $t;
	    } else {
		push @okaytags, $t;
	    }
	}
	if (@badtags) {
            &transcript("Unknown tag/s: ".join(', ', @badtags).".\n".
 			"Recognized are: ".join(' ', @gTags).".\n\n");
	}
	if (&setbug) {
	    if ($data->{keywords} eq '') {
		&transcript("There were no tags set.\n");
	    } else {
		&transcript("Tags were: $data->{keywords}\n");
	    }
	    if ($addsub eq "set") {
		$action= "Tags set to: " . join(", ", @okaytags);
	    } elsif ($addsub eq "add") {
		$action= "Tags added: " . join(", ", @okaytags);
	    } elsif ($addsub eq "sub") {
		$action= "Tags removed: " . join(", ", @okaytags);
	    }
	    do {
                &addmaintainers($data);
	        $data->{keywords} = '' if ($addsub eq "set");
		# Allow removing obsolete tags.
		if ($addsub eq "sub") {
		    foreach my $t (@badtags) {
	                $data->{keywords} = join ' ', grep $_ ne $t, 
		            split ' ', $data->{keywords};
		    }
		}
		# Now process all other additions and subtractions.
	        foreach my $t (@okaytags) {
	            $data->{keywords} = join ' ', grep $_ ne $t, 
			split ' ', $data->{keywords};
	            $data->{keywords} = "$t $data->{keywords}" unless($addsub eq "sub");
	        }
		$data->{keywords} =~ s/\s*$//;
            } while (&getnextbug);
	}
    } elsif (m/^(un)?block\s+\#?(-?\d+)\s+(by|with)\s+\s*(\S.*)?$/i) {
	$ok++;
	my $bugnum = $2; my $blockers = $4;
	$addsub = "add";
	$addsub = "sub" if ($1 eq "un");
	if ($bugnum =~ m/^-\d+$/ && defined $clonebugs{$bugnum}) {
	     $bugnum = $clonebugs{$bugnum};
	}

	my @okayblockers;
	my @badblockers;
	foreach my $b (split /[\s,]+/, $blockers) {
	    $b=~s/^\#//;
	    if ($b=~/[0-9]+/) {
		$ref=$b;
		if ($ref =~ m/^-\d+$/ && defined $clonebugs{$ref}) {
		     $ref = $clonebugs{$ref};
		}
		if (&getbug) {
		    push @okayblockers, $ref;

		    # add to the list all bugs that are merged with $b,
		    # because all of their data must be kept in sync
		    @thisbugmergelist= split(/ /,$data->{mergedwith});
		    &cancelbug;

		    foreach $ref (@thisbugmergelist) {
			if (&getbug) {
		           push @okayblockers, $ref;
			   &cancelbug;
			}
		    }
		}
		else {
		    &notfoundbug;
                    push @badblockers, $ref;
	    	}
	    }
	    else {
                push @badblockers, $b;
	    }
	}
	if (@badblockers) {
            &transcript("Unknown blocking bug/s: ".join(', ', @badblockers).".\n");
	}
	
	$ref=$bugnum;
	if (&setbug) {
	    if ($data->{blockedby} eq '') {
		&transcript("Was not blocked by any bugs.\n");
	    } else {
		&transcript("Was blocked by: $data->{blockedby}\n");
	    }
	    if ($addsub eq "set") {
		$action= "Blocking bugs of $bugnum set to: " . join(", ", @okayblockers);
	    } elsif ($addsub eq "add") {
		$action= "Blocking bugs of $bugnum added: " . join(", ", @okayblockers);
	    } elsif ($addsub eq "sub") {
		$action= "Blocking bugs of $bugnum removed: " . join(", ", @okayblockers);
	    }
	    my %removedblocks;
	    my %addedblocks;
	    do {
                &addmaintainers($data);
		my @oldblockerlist = split ' ', $data->{blockedby};
	        $data->{blockedby} = '' if ($addsub eq "set");
	        foreach my $b (@okayblockers) {
			$data->{blockedby} = manipset($data->{blockedby}, $b,
				($addsub ne "sub"));
	        }

		foreach my $b (@oldblockerlist) {
			if (! grep { $_ eq $b } split ' ', $data->{blockedby}) {
				push @{$removedblocks{$b}}, $ref;
			}
		}
		foreach my $b (split ' ', $data->{blockedby}) {
			if (! grep { $_ eq $b } @oldblockerlist) {
				push @{$addedblocks{$b}}, $ref;
			}
		}
            } while (&getnextbug);

	    # Now that the blockedby data is updated, change blocks data
	    # to match the changes.
	    foreach $ref (keys %addedblocks) {
	        if (&getbug) {
		    foreach my $b (@{$addedblocks{$ref}}) {
			$data->{blocks} = manipset($data->{blocks}, $b, 1);
		    }
		    &savebug;
                }
	    }
	    foreach $ref (keys %removedblocks) {
	        if (&getbug) {
		    foreach my $b (@{$removedblocks{$ref}}) {
			$data->{blocks} = manipset($data->{blocks}, $b, 0);
		    }
		    &savebug;
                }
	    }
	}
    } elsif (m/^retitle\s+\#?(-?\d+)\s+(\S.*\S)\s*$/i) {
        $ok++;
        $ref= $1; $newtitle= $2;
	$bug_affected{$ref}=1;
	if ($ref =~ m/^-\d+$/ && defined $clonebugs{$ref}) {
	    $ref = $clonebugs{$ref};
	}
        if (&getbug) {
            if (&checkpkglimit) {
                &foundbug;
                &addmaintainers($data);
                $data->{subject}= $newtitle;
                $action= "Changed $gBug title.";
                &savebug;
                &transcript("$action\n");
                if (length($data->{done})) {
                    &transcript("(By the way, that $gBug is currently marked as done.)\n");
                }
                &transcript("\n");
            } else {
                &cancelbug;
            }
        } else {
            &notfoundbug;
        }
    } elsif (m/^unmerge\s+\#?(-?\d+)$/i) {
	$ok++;
	$ref= $1;
	$bug_affected{$ref} = 1;
	if (&setbug) {
	    if (!length($data->{mergedwith})) {
		&transcript("$gBug is not marked as being merged with any others.\n\n");
		&nochangebug;
	    } else {
                $mergelowstate eq 'locked' || die "$mergelowstate ?";
		$action= "Disconnected #$ref from all other report(s).";
		@newmergelist= split(/ /,$data->{mergedwith});
                $discref= $ref;
		@bug_affected{@newmergelist} = 1 x @newmergelist;
                do {
                    &addmaintainers($data);
		    $data->{mergedwith}= ($ref == $discref) ? ''
                        : join(' ',grep($_ ne $ref,@newmergelist));
                } while (&getnextbug);
	    }
	}
    } elsif (m/^merge\s+#?(-?\d+(\s+#?-?\d+)+)\s*$/i) {
	$ok++;
        my @tomerge= sort { $a <=> $b } split(/\s+#?/,$1);
        my @newmergelist= ();
	my %tags = ();
	my %found = ();
	my %fixed = ();
        &getmerge;
        while (defined($ref= shift(@tomerge))) {
            &transcript("D| checking merge $ref\n") if $dl;
	    $ref+= 0;
	    if ($ref =~ m/^-\d+$/ && defined $clonebugs{$ref}) {
		$ref = $clonebugs{$ref};
	    }
	    next if grep($_ == $ref,@newmergelist);
	    if (!&getbug) { &notfoundbug; @newmergelist=(); last }
            if (!&checkpkglimit) { &cancelbug; @newmergelist=(); last; }
            &foundbug;
            &transcript("D| adding $ref ($data->{mergedwith})\n") if $dl;
	    $mismatch= '';
	    &checkmatch('package','m_package',$data->{package},@newmergelist);
	    &checkmatch('forwarded addr','m_forwarded',$data->{forwarded},@newmergelist);
	    $data->{severity} = '$gDefaultSeverity' if $data->{severity} eq '';
	    &checkmatch('severity','m_severity',$data->{severity},@newmergelist);
	    &checkmatch('blocks','m_blocks',$data->{blocks},@newmergelist);
	    &checkmatch('blocked-by','m_blockedby',$data->{blockedby},@newmergelist);
	    &checkmatch('done mark','m_done',length($data->{done}) ? 'done' : 'open',@newmergelist);
	    &checkmatch('owner','m_owner',$data->{owner},@newmergelist);
	    foreach my $t (split /\s+/, $data->{keywords}) { $tags{$t} = 1; }
	    foreach my $f (@{$data->{found_versions}}) { $found{$f} = 1; }
	    foreach my $f (@{$data->{fixed_versions}}) { $fixed{$f} = 1; }
	    if (length($mismatch)) {
	        &transcript("Mismatch - only $gBugs in same state can be merged:\n".
                            $mismatch."\n");
		&cancelbug; @newmergelist=(); last;
	    }
            push(@newmergelist,$ref);
            push(@tomerge,split(/ /,$data->{mergedwith}));
	    &cancelbug;
	}
	if (@newmergelist) {
            @newmergelist= sort { $a <=> $b } @newmergelist;
            $action= "Merged @newmergelist.";
	    delete @fixed{keys %found};
	    for $ref (@newmergelist) {
		&getbug || die "huh ?  $gBug $ref disappeared during merge";
                &addmaintainers($data);
		@bug_affected{@newmergelist} = 1 x @newmergelist;
		$data->{mergedwith}= join(' ',grep($_ != $ref,@newmergelist));
		$data->{keywords}= join(' ', keys %tags);
		$data->{found_versions}= [sort keys %found];
		$data->{fixed_versions}= [sort keys %fixed];
		&savebug;
	    }
    	    &transcript("$action\n\n");
	}
        &endmerge;
    } elsif (m/^forcemerge\s+\#?(-?\d+(?:\s+\#?-?\d+)+)\s*$/i) {
	$ok++;
	my @temp = split /\s+\#?/,$1;
	my $master_bug = shift @temp;
	my $master_bug_data;
	my @tomerge = sort { $a <=> $b } @temp;
        unshift @tomerge,$master_bug;
	&transcript("D| force merging ".join(',',@tomerge)."\n") if $dl;
	my @newmergelist= ();
	my %tags = ();
	my %found = ();
	my %fixed = ();
	# Here we try to do the right thing.
	# First, if the bugs are in the same package, we merge all of the found, fixed, and tags.
	# If not, we discard the found and fixed.
	# Everything else we set to the values of the first bug.
        &getmerge;
        while (defined($ref= shift(@tomerge))) {
            &transcript("D| checking merge $ref\n") if $dl;
	    $ref+= 0;
	    if ($ref =~ m/^-\d+$/ && defined $clonebugs{$ref}) {
		$ref = $clonebugs{$ref};
	    }
	    next if grep($_ == $ref,@newmergelist);
	    if (!&getbug) { &notfoundbug; @newmergelist=(); last }
            if (!&checkpkglimit) { &cancelbug; @newmergelist=(); last; }
            &foundbug;
            &transcript("D| adding $ref ($data->{mergedwith})\n") if $dl;
	    $master_bug_data = $data if not defined $master_bug_data;
	    if ($data->{package} ne $master_bug_data->{package}) {
		&transcript("Mismatch - only $gBugs in the same package can be forcibly merged:\n".
			    "$gBug $ref is not in the same package as $master_bug\n");
		&cancelbug; @newmergelist=(); last;
	    }
	    for my $t (split /\s+/,$data->{keywords}) {
		 $tags{$t} = 1;
	    }
	    @found{@{$data->{found_versions}}} = (1) x @{$data->{found_versions}};
	    @fixed{@{$data->{fixed_versions}}} = (1) x @{$data->{fixed_versions}};
	    push(@newmergelist,$ref);
            push(@tomerge,split(/ /,$data->{mergedwith}));
	    &cancelbug;
	}
	if (@newmergelist) {
            @newmergelist= sort { $a <=> $b } @newmergelist;
            $action= "Forcibly Merged @newmergelist.";
	    delete @fixed{keys %found};
	    for $ref (@newmergelist) {
		&getbug || die "huh ?  $gBug $ref disappeared during merge";
                &addmaintainers($data);
		@bug_affected{@newmergelist} = 1 x @newmergelist;
		$data->{mergedwith}= join(' ',grep($_ != $ref,@newmergelist));
		$data->{keywords}= join(' ', keys %tags);
		$data->{found_versions}= [sort keys %found];
		$data->{fixed_versions}= [sort keys %fixed];
		my @field_list = qw(forwarded package severity blocks blockedby owner done);
		@{$data}{@field_list} = @{$master_bug_data}{@field_list};
		&savebug;
	    }
    	    &transcript("$action\n\n");
	}
        &endmerge;
    } elsif (m/^clone\s+#?(\d+)\s+((-\d+\s+)*-\d+)\s*$/i) {
	$ok++;

	$origref = $1;
	@newclonedids = split /\s+/, $2;
	$newbugsneeded = scalar(@newclonedids);

	$ref = $origref;
	$bug_affected{$ref} = 1;
	if (&setbug) {
	    if (length($data->{mergedwith})) {
		&transcript("$gBug is marked as being merged with others.\n\n");
		&nochangebug;
	    } else {
        	&filelock("nextnumber.lock");
        	open(N,"nextnumber") || &quit("nextnumber: read: $!");
        	$v=<N>; $v =~ s/\n$// || &quit("nextnumber bad format");
        	$firstref= $v+0;  $v += $newbugsneeded;
		open(NN,">nextnumber"); print NN "$v\n"; close(NN);
        	&unfilelock;

		$lastref = $firstref + $newbugsneeded - 1;

		if ($newbugsneeded == 1) {
		    $action= "$gBug $origref cloned as bug $firstref.";
		} else {
		    $action= "$gBug $origref cloned as bugs $firstref-$lastref.";
		}

		my $blocks = $data->{blocks};
		my $blockedby = $data->{blockedby};
		
		&getnextbug;
		my $ohash = get_hashname($origref);
		my $clone = $firstref;
                @bug_affected{@newclonedids} = 1 x @newclonedids;
		for $newclonedid (@newclonedids) {
		    $clonebugs{$newclonedid} = $clone;
	    
		    my $hash = get_hashname($clone);
	            copy("db-h/$ohash/$origref.log", "db-h/$hash/$clone.log");
	            copy("db-h/$ohash/$origref.status", "db-h/$hash/$clone.status");
	            copy("db-h/$ohash/$origref.summary", "db-h/$hash/$clone.summary");
	            copy("db-h/$ohash/$origref.report", "db-h/$hash/$clone.report");
	            &bughook('new', $clone, $data);
		
		    # Update blocking info of bugs blocked by or blocking the
		    # cloned bug.
		    foreach $ref (split ' ', $blocks) {
			&getbug;
			$data->{blockedby} = manipset($data->{blockedby}, $clone, 1);
			&savebug;
		    }
		    foreach $ref (split ' ', $blockedby) {
			&getbug;
			$data->{blocks} = manipset($data->{blocks}, $clone, 1);
			&savebug;
		    }

		    $clone++;
		}
	    }
	}
    } elsif (m/^package\s+(\S.*\S)?\s*$/i) {
        $ok++;
	my @pkgs = split /\s+/, $1;
	if (scalar(@pkgs) > 0) {
		%limit_pkgs = map { ($_, 1) } @pkgs;
		&transcript("Ignoring bugs not assigned to: " . 
			join(" ", keys(%limit_pkgs)) . "\n\n");
	} else {
		%limit_pkgs = ();
		&transcript("Not ignoring any bugs.\n\n");
	}
    } elsif (m/^owner\s+\#?(-?\d+)\s+!$/i ? ($newowner = $replyto, 1) :
             m/^owner\s+\#?(-?\d+)\s+(\S.*\S)$/i ? ($newowner = $2, 1) : 0) {
        $ok++;
        $ref = $1;
	$bug_affected{$ref} = 1;
        if (&setbug) {
            if (length $data->{owner}) {
                $action = "Owner changed from $data->{owner} to $newowner.";
            } else {
                $action = "Owner recorded as $newowner.";
            }
            if (length $data->{done}) {
                $extramessage = "(By the way, this $gBug is currently " .
                                "marked as done.)\n";
            }
            do {
                &addmaintainers($data);
                $data->{owner} = $newowner;
            } while (&getnextbug);
        }
    } elsif (m/^noowner\s+\#?(-?\d+)$/i) {
        $ok++;
        $ref = $1;
	$bug_affected{$ref} = 1;
        if (&setbug) {
            if (length $data->{owner}) {
                $action = "Removed annotation that $gBug was owned by " .
                          "$data->{owner}.";
                do {
                    &addmaintainers($data);
                    $data->{owner} = '';
                } while (&getnextbug);
            } else {
                &transcript("$gBug is not marked as having an owner.\n\n");
                &nochangebug;
            }
        }
    } else {
        &transcript("Unknown command or malformed arguments to command.\n\n");
        if (++$unknowns >= 5) {
            &transcript("Too many unknown commands, stopping here.\n\n");
            last;
        }
    }
}
if ($procline>$#bodylines) {
    &transcript(">\nEnd of message, stopping processing here.\n\n");
}
if (!$ok && !quickabort) {
    &transcript("No commands successfully parsed; sending the help text(s).\n");
    &sendhelp;
    &transcript("\n");
}

&transcript("MC\n") if $dl>1;
@maintccs= ();
for $maint (keys %maintccreasons) {
&transcript("MM|$maint|\n") if $dl>1;
    next if $maint eq $replyto;
    $reasonstring= '';
    $reasonsref= $maintccreasons{$maint};
&transcript("MY|$maint|\n") if $dl>2;
    for $p (sort keys %$reasonsref) {
&transcript("MP|$p|\n") if $dl>2;
        $reasonstring.= ', ' if length($reasonstring);
        $reasonstring.= $p.' ' if length($p);
        $reasonstring.= join(' ',map("#$_",sort keys %{$$reasonsref{$p}}));
    }
    if (length($reasonstring) > 40) {
	(substr $reasonstring, 37) = "...";
    }
    $reasonstring = "" if (!defined($reasonstring));
    push(@maintccs,"$maint ($reasonstring)");
    push(@maintccaddrs,"$maint");
}

$maintccs = ""; 
if (@maintccs) {
    &transcript("MC|@maintccs|\n") if $dl>2;
    $maintccs .= "Cc: " . join(",\n    ",@maintccs) . "\n";
}

# Add Bcc's to subscribed bugs
push @bcc, map {"bugs=$_\@$gListDomain"} keys %bug_affected;

if (!defined $header{'subject'} || $header{'subject'} eq "") {
  $header{'subject'} = "your mail";
}

$reply= <<END;
From: $gMaintainerEmail ($gProject $gBug Tracking System)
To: $replyto
${maintccs}Subject: Processed: $header{'subject'}
In-Reply-To: $header{'message-id'}
References: $header{'message-id'}
Message-ID: <handler.s.$nn.transcript\@$gEmailDomain>
Precedence: bulk
X-$gProject-PR-Message: transcript

${transcript}Please contact me if you need assistance.

$gMaintainer
(administrator, $gProject $gBugs database)
$extras
END

$repliedshow= join(', ',$replyto,@maintccaddrs);
&filelock("lock/-1");
open(AP,">>db-h/-1.log") || &quit("open db-h/-1.log: $!");
print(AP
      "\2\n$repliedshow\n\5\n$reply\n\3\n".
      "\6\n".
      "<strong>Request received</strong> from <code>".
      &sani($header{'from'})."</code>\n".
      "to <code>".&sani($controlrequestaddr)."</code>\n".
      "\3\n".
      "\7\n",@{escapelog(@log)},"\n\3\n") || &quit("writing db-h/-1.log: $!");
close(AP) || &quit("open db-h/-1.log: $!");
&unfilelock;
utime(time,time,"db-h");

&sendmailmessage($reply,exists $header{'x-debbugs-no-ack'}?():$replyto,@maintccaddrs,@bcc);

unlink("incoming/P$nn") || &quit("unlinking incoming/P$nn: $!");

sub sendmailmessage {
    local ($message,@recips) = @_;
    $message = "X-Loop: $gMaintainerEmail\n" . $message;
    send_mail_message(message    => $message,
		      recipients => \@recips,
		     );
    $midix++;
}

sub sendhelp {
        &sendtxthelpraw("bug-log-mailserver.txt","instructions for request\@$gEmailDomain");
        &sendtxthelpraw("bug-maint-mailcontrol.txt","instructions for control\@$gEmailDomain")
            if $control;
}

#sub unimplemented {
#    &transcript("Sorry, command $_[0] not yet implemented.\n\n");
#}

sub checkmatch {
    local ($string,$mvarname,$svarvalue,@newmergelist) = @_;
    local ($mvarvalue);
    if (@newmergelist) {
        eval "\$mvarvalue= \$$mvarname";
        &transcript("D| checkmatch \`$string' /$mvarname/$mvarvalue/$svarvalue/\n")
            if $dl;
        $mismatch .=
            "Values for \`$string' don't match:\n".
            " #$newmergelist[0] has \`$mvarvalue';\n".
            " #$ref has \`$svarvalue'\n"
            if $mvarvalue ne $svarvalue;
    } else {
        &transcript("D| setupmatch \`$string' /$mvarname/$svarvalue/\n")
            if $dl;
        eval "\$$mvarname= \$svarvalue";
    }
}

sub checkpkglimit {
    if (keys %limit_pkgs and not defined $limit_pkgs{$data->{package}}) {
        &transcript("$gBug number $ref belongs to package $data->{package}, skipping.\n\n");
        return 0;
    }
    return 1;
}

sub manipset {
    my $list = shift;
    my $elt = shift;
    my $add = shift;

    my %h = map { $_ => 1 } split ' ', $list;
    if ($add) {
        $h{$elt}=1;
    }
    else {
	delete $h{$elt};
    }
    return join ' ', sort keys %h;
}

# High-level bug manipulation calls
# Do announcements themselves
#
# Possible calling sequences:
#    setbug (returns 0)
#    
#    setbug (returns 1)
#    &transcript(something)
#    nochangebug
#
#    setbug (returns 1)
#    $action= (something)
#    do {
#      (modify s_* variables)
#    } while (getnextbug);

sub nochangebug {
    &dlen("nochangebug");
    $state eq 'single' || $state eq 'multiple' || die "$state ?";
    &cancelbug;
    &endmerge if $manybugs;
    $state= 'idle';
    &dlex("nochangebug");
}

sub setbug {
    &dlen("setbug $ref");
    if ($ref =~ m/^-\d+/) {
        if (!defined $clonebugs{$ref}) {
            &notfoundbug;
            &dlex("setbug => noclone");
            return 0;
        }
        $ref = $clonebugs{$ref};
    }
    $state eq 'idle' || die "$state ?";
    if (!&getbug) {
        &notfoundbug;
        &dlex("setbug => 0s");
        return 0;
    }

    if (!&checkpkglimit) {
        &cancelbug;
        return 0;
    }

    @thisbugmergelist= split(/ /,$data->{mergedwith});
    if (!@thisbugmergelist) {
        &foundbug;
        $manybugs= 0;
        $state= 'single';
        $sref=$ref;
        &dlex("setbug => 1s");
        return 1;
    }
    &cancelbug;
    &getmerge;
    $manybugs= 1;
    if (!&getbug) {
        &notfoundbug;
        &endmerge;
        &dlex("setbug => 0mc");
        return 0;
    }
    &foundbug;
    $state= 'multiple'; $sref=$ref;
    &dlex("setbug => 1m");
    return 1;
}

sub getnextbug {
    &dlen("getnextbug");
    $state eq 'single' || $state eq 'multiple' || die "$state ?";
    &savebug;
    if (!$manybugs || !@thisbugmergelist) {
        length($action) || die;
        &transcript("$action\n$extramessage\n");
        &endmerge if $manybugs;
        $state= 'idle';
        &dlex("getnextbug => 0");
        return 0;
    }
    $ref= shift(@thisbugmergelist);
    &getbug || die "bug $ref disappeared";
    &foundbug;
    &dlex("getnextbug => 1");
    return 1;
}

# Low-level bug-manipulation calls
# Do no announcements
#
#    getbug (returns 0)
#
#    getbug (returns 1)
#    cancelbug
#
#    getmerge
#    $action= (something)
#    getbug (returns 1)
#    savebug/cancelbug
#    getbug (returns 1)
#    savebug/cancelbug
#    [getbug (returns 0)]
#    &transcript("$action\n\n")
#    endmerge

sub notfoundbug { &transcript("$gBug number $ref not found.\n\n"); }
sub foundbug { &transcript("$gBug#$ref: $data->{subject}\n"); }

sub getmerge {
    &dlen("getmerge");
    $mergelowstate eq 'idle' || die "$mergelowstate ?";
    &filelock('lock/merge');
    $mergelowstate='locked';
    &dlex("getmerge");
}

sub endmerge {
    &dlen("endmerge");
    $mergelowstate eq 'locked' || die "$mergelowstate ?";
    &unfilelock;
    $mergelowstate='idle';
    &dlex("endmerge");
}

sub getbug {
    &dlen("getbug $ref");
    $lowstate eq 'idle' || die "$state ?";
    if (($data = &lockreadbug($ref))) {
        $sref= $ref;
        $lowstate= "open";
        &dlex("getbug => 1");
        $extramessage='';
        return 1;
    }
    $lowstate= 'idle';
    &dlex("getbug => 0");
    return 0;
}

sub cancelbug {
    &dlen("cancelbug");
    $lowstate eq 'open' || die "$state ?";
    &unfilelock;
    $lowstate= 'idle';
    &dlex("cancelbug");
}

sub savebug {
    &dlen("savebug $ref");
    $lowstate eq 'open' || die "$lowstate ?";
    length($action) || die;
    $ref == $sref || die "read $sref but saving $ref ?";
    my $hash = get_hashname($ref);
    open(L,">>db-h/$hash/$ref.log") || &quit("opening db-h/$hash/$ref.log: $!");
    print(L
          "\6\n".
          "<strong>".&sani($action)."</strong>\n".
          "Request was from <code>".&sani($header{'from'})."</code>\n".
          "to <code>".&sani($controlrequestaddr)."</code>. \n".
          "\3\n".
          "\7\n",@{escapelog(@log)},"\n\3\n") || &quit("writing db-h/$hash/$ref.log: $!");
    close(L) || &quit("closing db-h/$hash/$ref.log: $!");
    unlockwritebug($ref, $data);
    $lowstate= "idle";
    &dlex("savebug");
}

sub dlen {
    return if !$dl;
    &transcript("C> @_ ($state $lowstate $mergelowstate)\n");
}

sub dlex {
    return if !$dl;
    &transcript("R> @_ ($state $lowstate $mergelowstate)\n");
}

sub transcript {
    print $_[0] if $debug;
    $transcript.= $_[0];
}

sub urlsanit {
    my $url = shift;
    $url =~ s/%/%25/g;
    $url =~ s/\+/%2b/g;
    my %saniarray = ('<','lt', '>','gt', '&','amp', '"','quot');
    $url =~ s/([<>&"])/\&$saniarray{$1};/g;
    return $url;
}

sub sendlynxdoc {
    &sendlynxdocraw;
    &transcript("\n");
    $ok++;
}

sub sendtxthelp {
    &sendtxthelpraw;
    &transcript("\n");
    $ok++;
}

sub sendtxthelpraw {
    local ($relpath,$description) = @_;
    $doc='';
    open(D,"$gDocDir/$relpath") || &quit("open doc file $relpath: $!");
    while(<D>) { $doc.=$_; }
    close(D);
    &transcript("Sending $description in separate message.\n");
    &sendmailmessage(<<END.$doc,$replyto);
From: $gMaintainerEmail ($gProject $gBug Tracking System)
To: $replyto
Subject: $gProject $gBug help: $description
References: $header{'message-id'}
In-Reply-To: $header{'message-id'}
Message-ID: <handler.s.$nn.help.$midix\@$gEmailDomain>
Precedence: bulk
X-$gProject-PR-Message: doc-text $relpath

END
    $ok++;
}

sub sendlynxdocraw {
    local ($relpath,$description) = @_;
    $doc='';
    open(L,"lynx -nolist -dump http://$gCGIDomain/\Q$relpath\E 2>&1 |") || &quit("fork for lynx: $!");
    while(<L>) { $doc.=$_; }
    $!=0; close(L);
    if ($? == 255 && $doc =~ m/^\n*lynx: Can\'t access start file/) {
        &transcript("Information ($description) is not available -\n".
                    "perhaps the $gBug does not exist or is not on the WWW yet.\n");
         $ok++;
    } elsif ($?) {
        &transcript("Error getting $description (code $? $!):\n$doc\n");
    } else {
        &transcript("Sending $description.\n");
        &sendmailmessage(<<END.$doc,$replyto);
From: $gMaintainerEmail ($gProject $gBug Tracking System)
To: $replyto
Subject: $gProject $gBugs information: $description
References: $header{'message-id'}
In-Reply-To: $header{'message-id'}
Message-ID: <handler.s.$nn.info.$midix\@$gEmailDomain>
Precedence: bulk
X-$gProject-PR-Message: doc-html $relpath

END
         $ok++;
    }
}

sub addccaddress {
    my ($cca) = @_;
    $maintccreasons{$cca}{''}{$ref}= 1;
}

sub addmaintainers {
    # Data structure is:
    #   maintainer email address &c -> assoc of packages -> assoc of bug#'s
    my $data = shift;
    my ($p, $addmaint);
    &ensuremaintainersloaded;
    $anymaintfound=0; $anymaintnotfound=0;
    for $p (split(m/[ \t?,():]+/, $data->{package})) {
 	$p =~ y/A-Z/a-z/;
	$p =~ /([a-z0-9.+-]+)/;
	$p = $1;
	next unless defined $p;
	if (defined $gSubscriptionDomain) {
	    if (defined($pkgsrc{$p})) {
		addbcc("$pkgsrc{$p}\@$gSubscriptionDomain");
	    } else {
		addbcc("$p\@$gSubscriptionDomain");
	    }
	}
        if (defined $data->{severity} and defined $gStrongList and
                isstrongseverity($data->{severity})) {
            addbcc("$gStrongList\@$gListDomain");
        }
        if (defined($maintainerof{$p})) {
 	    $addmaint= $maintainerof{$p};
	    &transcript("MR|$addmaint|$p|$ref|\n") if $dl>2;
            $maintccreasons{$addmaint}{$p}{$ref}= 1;
	    print "maintainer add >$p|$addmaint<\n" if $debug;
        } else { 
	    print "maintainer none >$p<\n" if $debug; 
	    &transcript("Warning: Unknown package '$p'\n");
	    &transcript("MR|unknown-package|$p|$ref|\n") if $dl>2;
            $maintccreasons{$gUnknownMaintainerEmail}{$p}{$ref}= 1;
	}
    }

    if (length $data->{owner}) {
        $addmaint = $data->{owner};
        &transcript("MO|$addmaint|$data->{package}|$ref|\n") if $dl>2;
        $maintccreasons{$addmaint}{$data->{package}}{$ref} = 1;
        print "owner add >$data->{package}|$addmaint<\n" if $debug;
    }
}

sub ensuremaintainersloaded {
    my ($a,$b);
    return if $maintainersloaded++;
    open(MAINT,"$gMaintainerFile") || die &quit("maintainers open: $!");
    while (<MAINT>) {
	m/^\n$/ && next;
	m/^\s*$/ && next;
        m/^(\S+)\s+(\S.*\S)\s*\n$/ || &quit("maintainers bogus \`$_'");
        $a= $1; $b= $2; $a =~ y/A-Z/a-z/;
        $maintainerof{$a}= $2;
    }
    close(MAINT);
    open(MAINT,"$gMaintainerFileOverride") || die &quit("maintainers.override open: $!");
    while (<MAINT>) {
        m/^\n$/ && next;
        m/^\s*$/ && next;
        m/^(\S+)\s+(\S.*\S)\s*\n$/ || &quit("maintainers.override bogus \`$_'");
        $a= $1; $b= $2; $a =~ y/A-Z/a-z/;
        $maintainerof{$a}= $2;
    }

    open(SOURCES, "$gPackageSource") || &quit("pkgsrc open: $!");
    while (<SOURCES>) {
	next unless m/^(\S+)\s+\S+\s+(\S.*\S)\s*$/;
	my ($a, $b) = ($1, $2);
	$pkgsrc{lc($a)} = $b;
    }
    close(SOURCES);
}

sub sendinfo {
    local ($wherefrom,$path,$description) = @_;
    if ($wherefrom eq "ftp.d.o") {
      $doc = `lynx -nolist -dump http://ftp.debian.org/debian/indices/$path.gz 2>&1 | gunzip -cf` or &quit("fork for lynx/gunzip: $!");
      $! = 0;
      if ($? == 255 && $doc =~ m/^\n*lynx: Can\'t access start file/) {
          &transcript("$description is not available.\n");
          $ok++; return;
      } elsif ($?) {
          &transcript("Error getting $description (code $? $!):\n$doc\n");
          return;
      }
    } elsif ($wherefrom eq "local") {
      open P, "$path";
      $doc = do { local $/; <P> };
      close P;
    } else {
      &transcript("internal errror: info files location unknown.\n");
      $ok++; return;
    }
    &transcript("Sending $description.\n");
    &sendmailmessage(<<END.$doc,$replyto);
From: $gMaintainerEmail ($gProject $gBug Tracking System)
To: $replyto
Subject: $gProject $gBugs information: $description
References: $header{'message-id'}
In-Reply-To: $header{'message-id'}
Message-ID: <handler.s.$nn.info.$midix\@$gEmailDomain>
Precedence: bulk
X-$gProject-PR-Message: getinfo

$description follows:

END
    $ok++;
    &transcript("\n");
}
